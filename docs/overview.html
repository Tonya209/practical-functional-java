<html>
<head>
<title>Practical Functional Java</title>
<link rel="stylesheet" href="reveal.js-3.6.0/css/reveal.css">
<link rel="stylesheet" href="reveal.js-3.6.0/css/theme/moon.css">
<link rel="stylesheet" href="reveal.js-3.6.0/lib/css/obsidian.css">
<link rel="stylesheet" href="css/style.css">
</head>
<body>
  <div class="reveal">
    <div class="slides">
      <section>
        <h2>Practical Functional Java</h2>
        <h3>Jeff Butler</h3>
        <p>github.com/jeffgbutler/practical-functional-java</p>
      </section>

      <section>
        <h2>About Me</h2>
        <ul>
          <li>Enterprise Architect for DMI in Indianapolis</li>
          <li>Committer to Apache iBatis/MyBatis since 2005</li>
          <li>Creator of MyBatis Generator</li>
          <li>Creator of MyBatis Dynamic SQL</li>
          <li>Voracious reader, adventurous eater, lawn care enthusiast</li>
          <li>Desert Island disks include White Stripes, Beck, Nirvana, Jimmie Dale Gilmore, Marty Stuart</li>
        </ul>
      </section>

      <section>
        <h2>How this Workshop Came to Be</h2>
        <ul>
          <li>I finally learned JavaScript</li>
          <li>Java 8 Study Group</li>
          <li>"Clean Code" Book Clubs</li>
          <li>MyBatis Dynamic SQL</li>
          <li>These experiences have changed the way I think about coding.</li>
        </ul>
      </section>
      
      <section>
        <h2>Plan for the Workshop</h2>
        <ul>
          <li>Some thoughts about Functional Programming</li>
          <li>Immutability Review and Exercises</li>
          <li>Streams Review and Exercises</li>
          <li>Optionals Review and Exercises</li>
          <li>Two multi-step guided exercises</li>
          <li>Immutability Redux</li>
        </ul>
        <h3>Focus on Practical!</h3>
        <h3>Very Few $10 Vocabulary Words!</h3>
      </section>

      <section>
        <h2>Functional Programming Hype</h2>
        <ul>
          <li>Solves all your concurrency problems!</li>
          <li>The solution to Moore's Law slowing down!</li>
          <li>Super Trendy! Big Money!</li>
          <li>Retro/Vintage/Hipster Programming - Lisp is Cool Again!</li>
        </ul>
        <p align="left">But seriously, how many people in this room...</p>
        <ul>
          <li>have major concurrency problems?</li>
          <li>have a Moore's Law problem?</li>
        </ul>
      </section>
      
      <section>
        <h1>Why Are You Here?</h1>
      </section>
      
      <section>
        <h2>I want to be a functional programmer!</h2>
        <p class="fragment fade-in">Wrong answer</p>
      </section>

      <section>
        <h2>I want to be a better programmer!</h2>
      </section>

      <section>
        <h3>This is why we're here...</h3>
        <img src="images/CleanCode.jpg"/>
      </section>
      
      <section>
        <h3>What is clean code?</h3>
        <ul>
          <li>Meaningful Names</li>
          <li>Small methods</li>
          <li>Small Classes</li>
          <li>TDD</li>
          <li>SOLID Principles</li>
        </ul>
        <h4 class="fragment fade-in">Functional practices urge us towards clean code</h4>
      </section>
      
      <section>
        <h3>What is Functional Programming?</h3>
        <ul>
          <li>Functions as first class citizens?</li>
          <li>Pure functions?</li>
          <li>Lambdas?</li>
          <li>Closures?</li>
          <li>Recursion with Tail Call Optimization?</li>
          <li>Lazy streams?</li>
          <li>Immutability?</li>
          <li>Declarative vs. Imperative?</li>
          <li>Monads (Haskell)?</li>
          <li>Code as Data (Lisp)?</li>
        </ul>
      </section>

      <section>
        <h1>Argh!</h1>
        <p>No one can define it!</p>
        <p class="fragment">Except maybe Uncle Bob...</p>
      </section>
      
      <section>
        <h2>Setup Exercise</h2>
      </section>

<!-- Sections below move to other pages -->      
      
      <section>
        <h1>Stream Examples</h1>
        <p>All code examples in <code>examples.streams.StreamTest.java</code></p>
      </section>

      <section>
        <pre>
          <code class="java">
    // Streams can be created from a list
    private Stream&lt;ImmutablePerson&gt; getTheFlintstones() {
        List&lt;ImmutablePerson&gt; people = new ArrayList&lt;&gt;();
        
        people.add(ImmutablePerson.of("Fred", "Flintstone"));
        people.add(ImmutablePerson.of("Wilma", "Flintstone"));
        people.add(ImmutablePerson.of("Pebbles", "Flintstone"));

        return people.stream();
    }
          </code>
        </pre>
      </section>

      <section>
        <pre>
          <code class="java">
    // Streams can be created directly with the "of" method
    private Stream&lt;ImmutablePerson&gt; getTheRubbles() {
        return Stream.of(ImmutablePerson.of("Barney", "Rubble"),
                ImmutablePerson.of("Betty", "Rubble"),
                ImmutablePerson.of("Bamm Bamm", "Rubble"));
    }
          </code>
        </pre>
      </section>

      <section>
        <pre>
          <code class="java">
    // the "collect" method can be used to turn a stream into a List
    @Test
    public void testCollect() {
        List&lt;ImmutablePerson&gt; flintstones = getTheFlintstones()
                .collect(Collectors.toList());
        
        assertThat(flintstones.size()).isEqualTo(3);
        assertThat(flintstones.get(1).getFirstName()).isEqualTo("Wilma");
    }
          </code>
        </pre>
      </section>

      <section>
        <pre>
          <code class="java" data-noescape>
    // the "filter" method is used to create a new stream containing only
    // items that match the filter
    @Test
    public void testFilterLambda1() {
        List&lt;ImmutablePerson&gt; flintstones = getTheFlintstones()
              .filter(<mark>p -> p.getFirstName().equals("Fred") || p.getFirstName().equals("Wilma")</mark>)
              .collect(Collectors.toList());
        
        assertThat(flintstones.size()).isEqualTo(2);
        assertThat(flintstones.get(1).getFirstName()).isEqualTo("Wilma");
    }
          </code>
        </pre>
      </section>

      <section>
        <pre>
          <code class="java" data-noescape>
    // the "filter" method is used to create a new stream containing only
    // items that match the filter
    @Test
    public void testFilterWithLambda2() {
        List&lt;ImmutablePerson&gt; flintstones = getTheFlintstones()
                .filter(<mark>p -> {</mark>
                    <mark>return p.getFirstName().equals("Fred") || p.getFirstName().equals("Wilma");</mark>
                <mark>}</mark>)
                .collect(Collectors.toList());
        
        assertThat(flintstones.size()).isEqualTo(2);
        assertThat(flintstones.get(1).getFirstName()).isEqualTo("Wilma");
    }
          </code>
        </pre>
      </section>

      <section>
        <pre>
          <code class="java" data-noescape>
    // the "filter" method is used to create a new stream containing only
    // items that match the filter
    @Test
    public void testFilterWithMethodReference() {
        List&lt;ImmutablePerson&gt; flintstones = getTheFlintstones()
                .filter(<mark>this::isFredOrWilma</mark>)
                .collect(Collectors.toList());
        
        assertThat(flintstones.size()).isEqualTo(2);
        assertThat(flintstones.get(1).getFirstName()).isEqualTo("Wilma");
    }
    
    private boolean isFredOrWilma(ImmutablePerson p) {
        return p.getFirstName().equals("Fred") || p.getFirstName().equals("Wilma");
    }
          </code>
        </pre>
      </section>

      <section>
        <pre>
          <code class="java" style="max-height: 450px">
    // the "map" method is used to transform a stream from one type to another
    @Test
    public void getMap() {
        String directoryListing = getTheFlintstones()
                .map(this::personAsString)  // Stream&lt;ImmutablePerson&gt; -> Stream&lt;String&gt;
                .collect(Collectors.joining("\n"));
        
        String expected = "Flintstone, Fred\n"
                + "Flintstone, Wilma\n"
                + "Flintstone, Pebbles";
        
        assertThat(directoryListing).isEqualTo(expected);
    }
    
    private String personAsString(ImmutablePerson person) {
        return person.getLastName() + ", " + person.getFirstName();
    }
          </code>
        </pre>
      </section>

      <section>
        <pre>
          <code class="java">
    // the "sorted" method is used to reorder a Stream
    // can supply a lambda for the sort function, or use
    // the natural order of a comparable
    @Test
    public void testSorted() {
        String directoryListing = getTheFlintstones()
                .sorted((p1, p2) -> p1.getFirstName().compareTo(p2.getFirstName()))
                .map(this::personAsString)
                .collect(Collectors.joining("\n"));
        
        String expected = "Flintstone, Fred\n"
                + "Flintstone, Pebbles\n"
                + "Flintstone, Wilma";
        
        assertThat(directoryListing).isEqualTo(expected);
    }
          </code>
        </pre>
      </section>

      <section>
        <pre>
          <code class="java">
    // stream methods can be chained together
    @Test
    public void testStreamMethodChaining() {
        String directoryListing = getTheFlintstones()
                .filter(this::isFredOrWilma)
                .sorted((p1, p2) -> p1.getFirstName().compareTo(p2.getFirstName()))
                .map(this::personAsString)
                .collect(Collectors.joining("\n"));
        
        String expected = "Flintstone, Fred\n"
                + "Flintstone, Wilma";
        
        assertThat(directoryListing).isEqualTo(expected);
    }
          </code>
        </pre>
      </section>

      <section>
        <pre>
          <code class="java">
    // the skip function can be used to skip over items in a stream
    @Test
    public void testSkip() {
        String directoryListing = getTheFlintstones()
                .skip(1)
                .filter(this::isFredOrWilma)
                .sorted((p1, p2) -> p1.getFirstName().compareTo(p2.getFirstName()))
                .map(this::personAsString)
                .collect(Collectors.joining("\n"));
        
        String expected = "Flintstone, Wilma";
        
        assertThat(directoryListing).isEqualTo(expected);
    }
          </code>
        </pre>
      </section>

      <section>
        <pre>
          <code class="java" style="max-height: 500px">
    // flatMap is used to apply a many to one mapping 
    @Test
    public void testFlatMap1() {
        ImmutablePerson fred = ImmutablePerson.of("Fred", "Flintstone");
        fred = fred.withNickNames("The Fredmeister", "Yabba Dabba Dude");
        
        ImmutablePerson barney = ImmutablePerson.of("Barney",  "Rubble");
        barney = barney.withNickNames("The Barnster", "Little Buddy");

        String expectedAllNickNames = "The Fredmeister,Yabba Dabba Dude,"
                + "The Barnster,Little Buddy";
        
        // (not so good) map each ImmutablePerson to a Stream&lt;String&gt; of nicknames,
        // then use flatMap for flatten
        String allNickNames = Stream.of(fred, barney)  // Stream&lt;ImmutablePerson&gt;
                .map(ImmutablePerson::nickNames)  // Stream&lt;Stream&lt;String&gt;&gt;
                .flatMap(Function.identity()) // Stream&lt;String&gt;
                .collect(Collectors.joining(","));
        
        assertThat(allNickNames).isEqualTo(expectedAllNickNames);
    }
          </code>
        </pre>
      </section>

      <section>
        <pre>
          <code class="java" style="max-height: 500px">
    // flatMap is used to apply a many to one mapping 
    @Test
    public void testFlatMap2() {
        ImmutablePerson fred = ImmutablePerson.of("Fred", "Flintstone");
        fred = fred.withNickNames("The Fredmeister", "Yabba Dabba Dude");
        
        ImmutablePerson barney = ImmutablePerson.of("Barney",  "Rubble");
        barney = barney.withNickNames("The Barnster", "Little Buddy");

        String expectedAllNickNames = "The Fredmeister,Yabba Dabba Dude,"
                + "The Barnster,Little Buddy";
        
        // (better) use flatMap instead of map with the mapping function
        String allNickNames = Stream.of(fred, barney)  // Stream&lt;ImmutablePerson&gt;
                .flatMap(ImmutablePerson::nickNames)  // Stream&lt;String&gt;
                .collect(Collectors.joining(","));
        
        assertThat(allNickNames).isEqualTo(expectedAllNickNames);
    }
          </code>
        </pre>
      </section>

      <section>
        <pre>
          <code class="java">
    // streams can be concatenated with the concat method
    @Test
    public void testConcatenationWithConcat() {
        // concat is OK to use when concatenating two streams, but can cause problems
        // with multiple streams and recursion.  There is a warning in the JavaDocs
        // about being careful with concat.  If you have multiple streams to concatenate,
        // then it is better to use the flatMap technique below.
        List&lt;ImmutablePerson&gt; allPeople = Stream.concat(getTheFlintstones(), getTheRubbles())
                .collect(Collectors.toList());

        assertThat(allPeople.size()).isEqualTo(6);
        assertThat(allPeople.get(1).getFirstName()).isEqualTo("Wilma");
        assertThat(allPeople.get(4).getFirstName()).isEqualTo("Betty");
    }
          </code>
        </pre>
      </section>

      <section>
        <pre>
          <code class="java">
    // streams can also be concatenated with flatMap
    @Test
    public void testConcatenationWithFlatMap() {
        List&lt;ImmutablePerson&gt; allPeople = Stream.of(getTheFlintstones(), getTheRubbles())
                .flatMap(Function.identity())
                .collect(Collectors.toList());

        assertThat(allPeople.size()).isEqualTo(6);
        assertThat(allPeople.get(1).getFirstName()).isEqualTo("Wilma");
        assertThat(allPeople.get(4).getFirstName()).isEqualTo("Betty");
    }
          </code>
        </pre>
      </section>

      <section>
        <pre>
          <code class="java" style="max-height: 450px">
    // the Stream.forEach method is for side effects.  We don't want side effects,
    // so don't do this
    @Test
    public void testForEach() {
        StringBuilder sb = new StringBuilder();
        
        getTheFlintstones().forEach(p -> {
            sb.append(personAsString(p));
            sb.append("\n"); // no good way to tell if we are at the end of the stream
        });

        String expected = "Flintstone, Fred\n"
                + "Flintstone, Wilma\n"
                + "Flintstone, Pebbles\n"; // note the extra \n at the end
        
        assertThat(sb.toString()).isEqualTo(expected);
    }
          </code>
        </pre>
      </section>

      <section>
        <h4>Streams Summary</h4>
        <blockquote>
          Map/Filter/Collect can replace virtually all loop structures in your code and drive you towards cleaner code.
        </blockquote>
      </section>

      <section>
        <h1>Optional Examples</h1>
        <p>All code examples in <code>examples.optional.OptionalTest.java</code></p>
      </section>

      <section>
        <pre>
          <code class="java">
    // the map method is used to transform an optional if it exists
    @Test
    public void testOptionalMap() {
        Optional&lt;String&gt; name = Optional.of("Fred");
        
        Optional&lt;String&gt; upperName = name.map(String::toUpperCase);
        
        assertThat(upperName.isPresent()).isTrue();
        assertThat(upperName.get()).isEqualTo("FRED");
    }
          </code>
        </pre>
      </section>

      <section>
        <pre>
          <code class="java">
    // the map method works on an empty Optional - just returns an empty Optional
    @Test
    public void testOptionalMapOnEmpty() {
        Optional&lt;String&gt; emptyName = Optional.empty();  // or Optional.ofNullable(null);
        
        Optional&lt;String&gt; emptyUpperName = emptyName.map(String::toUpperCase);
        
        assertThat(emptyUpperName.isPresent()).isFalse();
        
        try {
            assertThat(emptyUpperName.get()).isEqualTo("FRED");
            fail("found a value on an empty Optional");
        } catch (NoSuchElementException e) {
            // ignore
        }
    }
          </code>
        </pre>
      </section>

      <section>
        <pre>
          <code class="java">
    // the filter method is used to test the value of an optional if present
    @Test
    public void testOptionalFilter() {
        Optional&lt;String&gt; name = Optional.of("Fred");
        
        Optional&lt;String&gt; fred = name.filter(s -> s.equals("Fred"));
        Optional&lt;String&gt; notFred = name.filter(s -> !s.equals("Fred"));
        
        assertThat(fred.isPresent()).isTrue();
        assertThat(notFred.isPresent()).isFalse();
    }
          </code>
        </pre>
      </section>

      <section>
        <pre>
          <code class="java">
    // just like streams, optional methods can be chained
    @Test
    public void testOptionalMethodChaining() {
        Optional&lt;String&gt; name = Optional.of("Fred");
        
        Optional&lt;String&gt; upperFred = name.filter(s -> s.equals("Fred"))
                .map(String::toUpperCase);
                
        assertThat(upperFred.isPresent()).isTrue();
        assertThat(upperFred.get()).isEqualTo("FRED");
    }
          </code>
        </pre>
      </section>

      <section>
        <pre>
          <code class="java" style="max-height: 450px">
    // orElse is used to supply a default value if the optional is empty
    @Test
    public void testOptionalOrElse() {
        Optional&lt;String&gt; fred = Optional.of("Fred");
        
        String upperFred = fred.filter(s -> s.equals("Fred"))
                .map(String::toUpperCase)
                .orElse("Unknown");
                
        assertThat(upperFred).isEqualTo("FRED");

        Optional&lt;String&gt; barney = Optional.of("Barney");
        
        upperFred = barney.filter(s -> s.equals("Fred"))
                .map(String::toUpperCase)
                .orElse("Unknown");
                
        assertThat(upperFred).isEqualTo("Unknown");
    }
          </code>
        </pre>
      </section>

      <section>
        <pre>
          <code class="java">
    // the Optional.ifPresent method is for side effects.
    // We don't want side effects, so don't do this
    @Test
    public void testOptionalIfPresent() {
        Optional&lt;String&gt; name = Optional.of("Fred");

        StringBuilder sb = new StringBuilder();
        name.ifPresent(s -> {
            sb.append(s.toUpperCase());
        });

        assertThat(sb.toString()).isEqualTo("FRED");
    }
          </code>
        </pre>
      </section>

      <section>
        <h4>Optionals Summary</h4>
        <blockquote>
          Optionals are a great solution for dealing with nulls.  Optional.map and Optional.filter
          can replace a whole class of if statements in your code.
        </blockquote>
      </section>

      <section>
        <h1>Function Composition</h1>
        <p>All code examples in <code>examples.composition.FunctionCompositionTest.java</code></p>
      </section>

      <section>
        <pre>
          <code class="java">
    // create a basic concatenation function
    private BiFunction&lt;String, String, String&gt; concat = (a, b) -> a + " " + b;
    
    // create a new function that calls the concatenation function, but
    // provides the first parameter as a constant
    private Function&lt;String, String&gt; hello = a -> concat.apply("Hello", a);

    @Test
    public void testHello() {
        String phrase = hello.apply("Fred");
        
        assertThat(phrase).isEqualTo("Hello Fred");
    }
          </code>
        </pre>
      </section>

      <section>
        <pre>
          <code class="java" style="max-height: 450px">
    // create a basic concatenation function
    private BiFunction&lt;String, String, String&gt; concat = (a, b) -> a + " " + b;
    
    // create a new function that calls the concatenation function, but
    // provides the first parameter as a constant
    private Function&lt;String, String&gt; hello = a -> concat.apply("Hello", a);

    @Test
    public void testHelloInStream() {
        String answer = Stream.of(ImmutablePerson.of("Fred", "Flintstone"),
                                  ImmutablePerson.of("Barney", "Rubble"))
                .map(ImmutablePerson::getFirstName)
                .map(hello)
                .collect(Collectors.joining(", "));

        assertThat(answer).isEqualTo("Hello Fred, Hello Barney");
    }
          </code>
        </pre>
      </section>

      <section>
        <h3>Suggestions for converting to functional style...</h3>
        <ul>
          <li>Never write another setter method</li>
          <li>Never write another loop - use Streams</li>
          <li>Never pass nulls around or do null checks - use Optionals</li>
          <li>Write pure methods</li>
          <li>Prefer method references - this will force you to write smaller functions</li> 
        </ul>
      </section>
      
      <section>
        <h1>Time to Code!</h1>
        <p>Two multi-step exercises...</p>
        <ul>
          <li>Create an XML Renderer</li>
          <li>Refactor a looping mess</li>
        </ul>
      </section>
    </div>
  </div>

  <script src="reveal.js-3.6.0/lib/js/head.min.js"></script>
  <script src="reveal.js-3.6.0/js/reveal.js"></script>
  <script>
    Reveal.initialize({
        slideNumber: 'c/t',
        dependencies: [
            // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
            { src: 'reveal.js-3.6.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },

            // Syntax highlight for <code> elements
            { src: 'reveal.js-3.6.0/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

            // Zoom in and out with Alt+click
            { src: 'reveal.js-3.6.0/plugin/zoom-js/zoom.js', async: true },

            // Speaker notes
            { src: 'reveal.js-3.6.0/plugin/notes/notes.js', async: true }
        ]
    });
  </script>
</body>
</html>
